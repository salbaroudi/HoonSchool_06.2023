::This file contains hoon expressions I use to test sub-components. 
::This file is not runnable, and the snippets are just pasted into the dojo.


:: First, lets define a simple list as an array

=/  mylist  [1 3 5 7 9 2 4 6 8 10 ~]  mylist

:: Operate on an array with turn. Lets kick a trap.

=/  mylist  [1 3 5 7 9 2 4 6 8 10 ~]
|- (turn mylist dec)


:: Implement list addition using tail-recursion (!).
=/  numlist  `(list @ud)`~[1 3 5 7 9 2 4 6 8 10]
=/  llen  (lent numlist)
=/  total  0
|-  
  ?~  numlist
    0 
  (add i.numlist $(numlist t.numlist))


:: Lets implement a block of code that checks an input list.
:: Is the list empty? Are there non-negative numbers? Are there non @ud data types present in our list?
:: ...we really need a mold to do our typechecking, else return an error.
=/  numlist  `(list @ud)`~[1 3 5 7 9 2 4 6 8 10]
?~  numlist  
"Error: List is empty. Check Input"  
^-  (list @ud)  numlist


:: Traverse a list, and create a second list that reverses the list 
=/  numlist  `(list @ud)`~[1 3 5 7 9 2 4 6 8 10]


:: Random-Access Read for an Array.snag will grab the element in the third position.
(snag 3 `(list @ud)`~[1 2 3 4])

::Random-Access Write for an Array. Use snap. 
(snap `(list @ud)`~[1 2 3 4]  3  99)